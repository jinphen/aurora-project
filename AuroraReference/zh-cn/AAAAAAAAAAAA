<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<article>
  <articleinfo>
    <title/>

    <author>
      <firstname/>

      <surname/>

      <affiliation>
        <orgname/>
      </affiliation>
    </author>

    <pubdate/>
  </articleinfo>

  <orderedlist>
    <listitem>
      <para/>
    </listitem>
  </orderedlist>

  <section>
    <title>【一】Aurora框架简介</title>

    <para>Aurora是一个基于J2EE的Web应用开发框架，主要面向企业应用。在介绍Aurora框架之前，我们先看看用Aurora开发出来的应用实例。鉴于企业应用通常都不会像J2EE宠物商店那么简单，我们将选择一个典型的业务：销售订单，来作为演示场景。我们的示例程序包括以下几个界面：销售订单录入，销售出库，销售订单查询。请点击此处查看在线演示程序：</para>

    <para>...</para>

    <para>从应用开发者的角度，Aurora与其它框架的最大区别，就是大多数功能都是通过XML配置文件，而不是Java代码来实现的。实际上，Aurora可以看做是一个配置解析器，通过解析配置文件来实现各种功能。我们以【...】这个演示界面为例，说明在Aurora框架下应用程序是如何开发出来的。</para>

    <para>【截图】</para>

    <para>首先我们来看前端界面部分。用户所访问的每一个界面（我们可以在demo系统中看到的.screen链接），都对应一个XML格式的配置文件，它在server端被解析，产生HTML输出，生成供浏览器展示的UI。以...界面为例，按各种条件查询数据，点击某条记录能够在一个弹出窗口中编辑数据，像这样一个典型的企业应用界面，其源代码如下：</para>

    <para>【Screen代码示例】</para>

    <para>源文件在&lt;init-procedure&gt;部分说明如何获取该界面所需的数据（如...，我们将在后面对其原理进行更详细的介绍），&lt;view&gt;部分说明整个界面是如何用基本的UI组件构建而成。例如，通过&lt;dataset&gt;组件，我们声明了在客户端端存储的数据集，以便实现主从数据联动、记录在客户端的新增修改删除、有效性校验等功能，并将它与后台提供实际数据存储服务的URL关联在一起；通过&lt;grid&gt;组件，我们以表格的形式将dataset中的数据展示出来，并提供编辑的功能；通过&lt;lov&gt;组件，我们可以提供对海量数据进行选择的组件，并支持auto-complete特性。</para>

    <para>在上面的例子中，我们通过这几个配置文件，就可以完成一个典型的应用界面。虽然Aurora是基于J2EE的开发框架，但这个通过Aurora开发的应用程序没有一行Java代码。Aurora也提供了基于Eclipse的IDE，可对这些配置文件进行快速创建、可视化编辑，并提供语义有效性检查，能在很大程度上消除配置错误引发的问题。在IDE专题部分会有更详细的介绍。</para>

    <para>【配图】</para>

    <para/>
  </section>

  <section>
    <title>【面向配置，SOA，RESTful】</title>

    <para>Aurora提供了一种面向配置的业务建模方式，能够快速实现数据库相关的操作，并以RESTful的风格将这些操作变为服务。</para>

    <para>在示例程序中，对...的查询及维护，就是通过这样一段配置来实现的：</para>

    <para>[BM代码示例]</para>

    <para>通过这个配置文件，我们可以实现基本的数据库操作，例如根据用户输入的条件执行动态查询SQL语句，对数据进行新增、修改，或包含各种组合的批量操作，这些功能可以直接通过Web
    service或简单的HTTP+JSON方式调用。例如，在浏览器中通过HTTP请求：</para>

    <para>[url]</para>

    <para>即表示执行对[BM名]的查询，筛选条件为....，按...排序，分页显示，每页...条记录。这个查询会返回一段JSON格式的数据：</para>

    <para>{ ... }</para>

    <para>如果以SOAP的方式发起请求：</para>

    <para>{ ... }</para>

    <para>则会得到标准的XML格式的结果：</para>

    <para>{ ... }</para>

    <para>对于[]/insert、[]/update、[]/delete分别表示对数据执行新增、更新、删除操作；而[]/batch_update则表示对一组数据进行批量操作，可同时执行新增或更改。</para>

    <para>【灵活的扩展机制】</para>

    <para>使用框架自动生成的SQL，虽然便利，但总会遇到一些特殊的需求，使得框架标准功能所产生的SQL无法直接使用。例如：执行删除操作时不是物理删除而是做标记；执行更改时需要同时保存历史记录；需要利用数据库的本地SQL扩展语法等。这些需求是与特定的产品、项目或使用场景相关的，框架本身无法穷举各种可能。
    Aurora
    BM提供了一种面向特性的扩展机制，使得开发者可以针对这类特殊需求开发插件式的代码。Aurora提供的基于数据耦合，事件驱动，过程抽象的扩展机制，使得这类插件代码非常简洁。
    例如，为利用Oracle数据库的sequence特性去生成主键，只需要在原有的BM文件中添加一句配置： &lt;o:sequence-pk
    xmlns:o="...." /&gt; 这样，生成的insert语句就由原先的标准SQL： insert into table_name (f1,
    f2, ..., fn) values (v1, v2, ... , vn) 变为 begin insert into table_name
    (f1, f2, ..., fn) values (f1_sequence.nextval, v2, ... , vn) returning f1
    into :p1; end; </para>

    <para>【固态的对象 vs 液态的数据】</para>

    <para>与常见的O/R映射工具不同的是，Aurora不使用静态java建模，没有关系数据库映射到java对象这样的步骤，而是以纯粹的数据容器作为数据的载体。应用开发者只要完成BM配置文件，保存到服务器约定的路径，就得到一组JSON或XML数据服务，可以立即在javascript或其他支持web
    service的语言中，对这些服务进行调用。对BM的修改也是即时生效，没有编译、重部署的步骤。我们甚至可以在运行时期动态生成这样的BM，或修改原有BM的配置，以实现特殊的需求——例如，通过植入一个拦截器，在BM文件被解析之前，动态删除当前用户没有权限去访问的字段，来实现可配置的列安全控制。</para>

    <para>使用纯容器而不是对象作为数据的承载体，一个显而易见的优势就是灵活性。传统的O/R
    Mapping机制所产生的对象，其结构是编译时期决定的，而容器所承载的数据可以在运行时期改变其内容与结构。Aurora提供了多种数据转换的处理器，可以将来自关系数据库的单层结构，转换为多级分组结构、树形层次结构、哈希表结构，或者对数据进行行列转置。我们来看下面的例子：</para>

    <para>{ } </para>

    <para>这些转换是完全通过配置来实现的，并且可以自由组合叠加。相比之下，静态的Java对象构成的模型无法在运行时期改变其固有结构，不能动态地增加或删除字段，也无法将其数据结构由数组变成多级层级。如果你需要做一个按客户、订单、订单行这样用三个层次去展示数据的界面，你就必须事先建立客户包含多个订单，每个订单包含多个订单行这样的对象层级结构；如果某一天需求改变了，要在客户中间增加一层收货地址，变为4级结构，你必须再回头修改多个Java对象的结构，修改一系列映射配置文件，重新编译、部署。而在Aurora中，你需要的仅仅是为层级数据转换器增加一行配置。</para>

    <para>【接口抽象 vs 过程抽象】</para>

    <para>作为面向对象开发方式强调接口抽象的补充，Aurora建立了一种过程抽象的机制。Aurora将数据从存储层的获取到展示层的输出（假如我们把为web
    service提供的XML数据也看成是一种特定类型的输出），看做是一个数据容器被一系列彼此完全独立的处理器依次处理的过程，而非传统面对对象模式下一系列对象方法调用的组合。下图展示了一个典型操作的例子。首先，前置处理器将当前用户的id、角色、登录语言等信息放入容器中，第一个处理器执行SQL查询，将数据从JDBC结果集转换为List+Map结构的复合数据容器，每条记录对应一个Map，整个数据集对应一个List；第二个处理器对数据进行多语言的转换，将数据库中按代码存储的字段，翻译成当前用户所使用的语言下实际的描述；第三个处理器进行权限控制，将当前用户没有权限查看的字段从Map中移除；第四个处理器进行数据结构的转换，将数据由一维链表转换为多级层次结构，以适应展示层界面的需要。</para>

    <para>在这个过程中，数据由数据库中提取，到最终展示，要经过那些处理步骤，每个步骤由谁来处理，完全是通过配置而非硬编码来实现的。开发人员可以在任意一点截获控制，加入自己的处理器，实现特殊的需求。每个处理器都是功能单一、高度内聚、结构简单、易于维护的，并且具有很高的可重用性。处理器之间，通过数据容器进行参数的传递，实现了最为松散的耦合级别——数据耦合。</para>

    <para>相比传统的O/R
    Mapping、存储层与展示层之间通过对象来传递数据、展示层调用对象的方法来存储属性这种完全依赖于接口调用的开发模式，Aurora配置驱动、面向数据、过程抽象+处理器的实现机制，体现了无与伦比的灵活性，实现了更高程度的代码复用。</para>

    <para/>
  </section>
</article>
